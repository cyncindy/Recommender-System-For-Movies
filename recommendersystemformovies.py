# -*- coding: utf-8 -*-
"""RecommenderSystemForMovies.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RZ4Y5DzuGrFYhjk6YSR7XV0SnSTZ7UEU

**Nama: Cindy Deviana Atmakusuma**

Proyek ini menggunakan dataset dari Kaggle untuk memberikan rekomendasi film berdasarkan kemiripan genre dan juga berdasarkan rating yang diberikan oleh pengguna

Link: https://www.kaggle.com/datasets/gargmanas/movierecommenderdataset

# **Import Library yang digunakan**
"""

# Install public API Kaggle
!pip install -q kaggle

# Impor semua library yang diperlukan
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path

# Impor library TF-IDF
from sklearn.feature_extraction.text import TfidfVectorizer

# Impor library Cosine Similarity
from sklearn.metrics.pairwise import cosine_similarity

# Impor library K-Nearest Neighbor
from sklearn.neighbors import KNeighborsClassifier

# Impor library SVD
from scipy.sparse.linalg import svds

# Impor library MSE
from sklearn.metrics import mean_squared_error

"""# **Data Understanding**

Merupakan tahapan yang dilakukan untuk memahami informasi pada data dan juga berguna dalam menentukan kualitas data yang didapatkan.

**1. Data Loading**

Tahapan ini memuat dataset yang digunakan agar dapat dipahami.
"""

# Membuat direktori baru bernama kaggle
!rm -rf ~/.kaggle && mkdir ~/.kaggle/

# Menyalin berkas kaggle.json pada direktori aktif saat ini ke direktori kaggle
!mv kaggle.json ~/.kaggle/kaggle.json

# Mengubah permission berkas
!chmod 600 ~/.kaggle/kaggle.json

# Download dataset
!kaggle datasets download -d gargmanas/movierecommenderdataset

# Ekstrak berkas zip
!unzip /content/movierecommenderdataset.zip

movies = pd.read_csv('/content/movies.csv')
ratings = pd.read_csv('/content/ratings.csv')

print('Jumlah data movie: ', len(movies.movieId.unique()))
print('Jumlah data user yang memberikan rating: ', len(ratings.userId.unique()))
print('Jumlah data movie yang telah diberikan peringkat: ', len(ratings.movieId.unique()))

"""**2. Univariate Exploratory Data Analysis**

Variabel-variabel pada dataset adalah sebagai berikut:

Pada file movies.csv terdapat tiga fitur sebagai berikut:
1. movieId yang merupakan ID unik untuk setiap movie
2. title yang merupakan judul movie
3. genres yang merupakan genre movie
"""

movies.info()

"""Pada file ratings.csv terdapat empat fitur sebagai berikut:

1. userId yaitu ID pengguna yang memberikan rating
2. movieId yaitu ID film yang diberikan rating
3. rating yaitu rating yang diberikan oleh pengguna
4. timestamp yaitu waktu dimana peringkat telah diberikan
"""

ratings.head()

ratings.describe()

"""# **Data Preprocessing**

**1. Menggabungkan Movie**

Pada tahap ini menggabungkan file movies.csv dan ratings.csv dengan fungsi concatenate berdasarkan pada movieId, dan diperoleh seluruh data pada variabel all_movies.
"""

# Menggabungkan seluruh movieId pada kategori movie
all_movies = np.concatenate((
    movies.movieId.unique(),
    ratings.movieId.unique()
))

# Mengurutkan data dan menghapus data yang sama
all_movies = np.sort(np.unique(all_movies))

print('Jumlah seluruh data movie berdasarkan pada movieId: ', len(all_movies))

# Menghitung jumlah keseluruhan user
all_users = ratings['userId'].unique()

print('Jumlah seluruh user: ', len(all_users))

# Menggabungkan file movies dan ratings ke dalam dataframe movies_info serta menggabungkan dataframe ratings dengan movies_info berdasarkan nilai movieId
movies_info = pd.concat([movies, ratings])
df_movie = pd.merge(ratings, movies_info, on='movieId', how='left')
df_movie

"""Dilakukan pula cek missing value karena terdapat banyak missing value seperti yang dapat dilihat diatas"""

df_movie.isnull().sum()

"""Menggabungkan rating berdasarkan movieId"""

df_movie.groupby('movieId').sum()

"""**2. Menggabungkan Data dengan Fitur Nama Movie**

Disini didefinisikan pula all_rate_movies dengan variabel ratings
"""

all_rate_movies = ratings
all_rate_movies

# Menggabungkan all_rate_movies dengan dataframe movies berdasarkan movieId
all_movies = pd.merge(all_rate_movies, movies[['movieId','title','genres']], on='movieId', how='left')
all_movies

"""# **Data Preparation**

Mengatasi Missing Value
"""

# Mengecek adanya data null
all_movies.isnull().sum()

all_movies.sort_values('movieId', ascending=True)

"""Mengecek jumlah movie secara keseluruhan"""

len(all_movies.movieId.unique())

"""Membuat variabel preparation lalu mengurutkan data tersebut berdasarkan movieId"""

dataprep = all_movies
dataprep.sort_values('movieId')

"""Menghapus data duplikat dengan fungsi drop_duplicates() berdasarkan movieId"""

dataprep = dataprep.drop_duplicates('movieId')
dataprep

# Mengonversi data series 'movieId' menjadi dalam bentuk list
movie_id = dataprep['movieId'].tolist()

# Mengonversi data series 'title' menjadi dalam bentuk list
movie_name = dataprep['title'].tolist()

# Mengonversi data series 'genres' menjadi dalam bentuk list
movie_genre = dataprep['genres'].tolist()

print(len(movie_id))
print(len(movie_name))
print(len(movie_genre))

# Membuat dictionary untuk data 'movie_id', 'movie_name', dan 'movie_genre'
movie_new = pd.DataFrame({
    'id': movie_id,
    'movie_name': movie_name,
    'genre': movie_genre
})
movie_new

"""# **Model Development & Evaluation**

Pada tahap ini, model machine learning yang akan dikembangkan yaitu Content-Based Filtering dan juga Collaborative Filtering. Untuk Content-Based Filtering, model dibuat dengan pendekatan Cosine Similarity dan K-Nearest Neighbor. Sedangkan untuk Collaborative Filtering, model dibuat dengan pendekatan Singular Value Decomposition. Content-Based Filtering melibatkan genre film yang disukai pengguna lalu akan diberikan rekomendasi film berdasarkan genre film yang disukai pengguna di masa lalu. Pada Collaborative Filtering melibatkan tingkat rating yang diberikan oleh pengguna pada movie.

**1. Content Based Filtering (Cosine Similarity)**
"""

# Inisialisasi TfidfVectorizer
tf = TfidfVectorizer()

# Melakukan perhitungan idf pada data genre
tf.fit(movie_new['genre'])

# Mapping array dari fitur index integer ke fitur nama
tf.get_feature_names_out()

# Melakukan fit lalu ditransformasikan ke bentuk matrix
tfidf_matrix = tf.fit_transform(movie_new['genre'])

# Melihat ukuran matrix tfidf
tfidf_matrix.shape

# Mengubah vektor tf-idf dalam bentuk matriks dengan fungsi todense()
tfidf_matrix.todense()

# Membuat dataframe untuk melihat tf-idf matrix
pd.DataFrame(
    tfidf_matrix.todense(),
    columns=tf.get_feature_names_out(),
    index=movie_new.movie_name
).sample(22, axis=1).sample(10, axis=0)

# Menghitung cosine similarity pada matrix tf-idf
cosine_sim = cosine_similarity(tfidf_matrix)
cosine_sim

# Membuat dataframe dari variabel cosine_sim dengan baris dan kolom berupa nama movie
cosine_sim_df = pd.DataFrame(cosine_sim, index=movie_new['movie_name'], columns=movie_new['movie_name'])
print('Shape:', cosine_sim_df.shape)

# Melihat similarity matrix pada setiap movie
cosine_sim_df.sample(5, axis=1).sample(10, axis=0)

"""Tahap ini yaitu membuat fungsi cosim_movie_recommendation dengan parameter-parameter berikut:
- nama_movie yaitu nama judul movie (index kemiripan dataframe)
- similarity_data yaitu dataframe mengenai similarity yang telah didefinisikan sebelumnya
- items yaitu nama dan fitur yang digunakan untuk mendefinisikan kemiripan, disini adalah 'movie_name' dan 'genre'
- k yaitu banyak rekomendasi yang diinginkan
"""

def cosim_movie_recommendations(nama_movie, similarity_data=cosine_sim_df, items=movie_new[['movie_name','genre']], k=5):
  index = similarity_data.loc[:,nama_movie].to_numpy().argpartition(
      range(-1, -k, -1))

  # Mengambil data dengan similarity terbesar dari index yang ada
  closest = similarity_data.columns[index[-1:-(k+2):-1]]

  # Drop nama_movie agar nama movie yang dicari tidak muncul dalam daftar rekomendasi
  closest = closest.drop(nama_movie, errors='ignore')

  return pd.DataFrame(closest).merge(items).head(k)

"""Menemukan rekomendasi film yang mirip dengan John Wick: Chapter Two (2017)"""

movie_new[movie_new.movie_name.eq('John Wick: Chapter Two (2017)')]

"""Mendapatkan rekomendasi film yang mirip dengan John Wick: Chapter Two (2017)."""

cosim_movie_recommendations('John Wick: Chapter Two (2017)')

"""Berdasarkan hasil rekomendasi tersebut, diketahui bahwa John Wick: Chapter Two (2017) termasuk ke dalam genre Action|Crime|Thriller. Dari 5 item yang direkomendasikan, 5 item memiliki genre yang sama dengan yang dicari yaitu Action|Crime|Thriller (similar). Dengan demikian, jika diukur menggunakan metrik Precision maka dapat diketahui bahwa hasil precision sistem sebesar 5/5 atau 100%.

**2. Content Based Filtering (K-Nearest Neighbor)**
"""

# Menggunakan matriks tf-idf sebagai fitur dan nama film sebagai label
X = np.asarray(tfidf_matrix.todense())
y = movie_new['movie_name']

# Inisialisasi KNN dengan jumlah tetangga (k) yang diinginkan
knn = KNeighborsClassifier(n_neighbors=5)

# Melatih model KNN
knn.fit(X, y)

# Fungsi untuk mendapatkan rekomendasi film berdasarkan KNN
def knn_movie_recommendations(nama_movie, k=5):
    # Mencari index dari film yang dicari
    index = np.where(y == nama_movie)[0]

    # Menggunakan model KNN untuk memprediksi film yang paling mirip
    distances, indices = knn.kneighbors(X[index], n_neighbors=k+1)

    # Mengambil nama film yang paling mirip
    closest_movies = y[indices[0][1:]]

    # Mengambil genre dari film yang paling mirip
    closest_movies_genres = movie_new.loc[movie_new['movie_name'].isin(closest_movies), ['movie_name', 'genre']]

    return closest_movies_genres

"""Mendapatkan rekomendasi film yang mirip dengan John Wick: Chapter Two (2017)."""

knn_movie_recommendations('John Wick: Chapter Two (2017)')

"""Berdasarkan hasil rekomendasi tersebut, diketahui bahwa John Wick: Chapter Two (2017) termasuk ke dalam genre Action|Crime|Thriller. Dari 5 item yang direkomendasikan, 5 item memiliki genre yang sama dengan yang dicari yaitu Action|Crime|Thriller (similar). Dengan demikian, jika diukur menggunakan metrik Precision maka dapat diketahui bahwa hasil precision sistem sebesar 5/5 atau 100%.

**3. Collaborative Filtering (SVD)**
"""

# Membaca dataset
df = ratings
df

# Mengubah userId dan movieId menjadi list tanpa nilai yang sama
user_ids = df['userId'].unique().tolist()
movie_ids = df['movieId'].unique().tolist()

# Melakukan encoding userId dan movieId
user_to_user_encoded = {x: i for i, x in enumerate(user_ids)}
movie_to_movie_encoded = {x: i for i, x in enumerate(movie_ids)}

# Melakukan proses encoding angka ke userId dan movieId
user_encoded_to_user = {i: x for i, x in enumerate(user_ids)}
movie_encoded_to_movie = {i: x for i, x in enumerate(user_ids)}

print('list userId: ', user_ids)
print('encoded userId : ', user_to_user_encoded)
print('encoded angka ke userId: ', user_encoded_to_user)
print('list movieId: ', movie_ids)
print('encoded movieId : ', movie_to_movie_encoded)
print('encoded angka ke movieId: ', movie_encoded_to_movie)

# Mendapatkan jumlah user
num_users = len(user_to_user_encoded)
print(num_users)

# Mendapatkan jumlah movie
num_movie = len(movie_encoded_to_movie)
print(num_movie)

# Mengubah rating menjadi nilai float
df['ratings'] = df['rating'].values.astype(np.float32)

# Membuat matriks rating
num_users = len(user_to_user_encoded)
num_movies = len(movie_to_movie_encoded)

# Mengisi matriks rating dengan 0
rating_matrix = np.zeros((num_users, num_movies))

# Mengisi matriks rating dengan rating yang ada
for index, row in df.iterrows():
    user_encoded = user_to_user_encoded[row['userId']]
    movie_encoded = movie_to_movie_encoded[row['movieId']]
    rating_matrix[user_encoded, movie_encoded] = row['rating']

# Melakukan SVD dan menghitung MSE
def calculate_mse(k):
    U, sigma, Vt = svds(rating_matrix, k=k)
    predicted_ratings = np.dot(np.dot(U, np.diag(sigma)), Vt)
    mse = mean_squared_error(rating_matrix, predicted_ratings)
    return mse

# Mencari nilai k yang memberikan MSE terkecil
best_k = 1
best_mse = float('inf')
for k in range(1, 51):
    mse = calculate_mse(k)
    if mse < best_mse:
        best_k = k
        best_mse = mse

print(f"Best k: {best_k}, MSE: {best_mse}")

# Melakukan SVD dengan nilai k terbaik
U, sigma, Vt = svds(rating_matrix, k=best_k)
predicted_ratings = np.dot(np.dot(U, np.diag(sigma)), Vt)

def recommend_movies(user_id, num_recommendations=10):
    user_encoded = user_to_user_encoded[user_id]
    user_ratings = predicted_ratings[user_encoded]
    sorted_indices = np.argsort(user_ratings)[::-1]

    top_movie_indices = sorted_indices[:num_recommendations]

    recommended_movie_ids = [movie_encoded_to_movie[i] for i in top_movie_indices if i in movie_encoded_to_movie]

    recommended_movie_names = [movies[movies['movieId'] == movie_id]['title'].values[0] if not movies[movies['movieId'] == movie_id]['title'].empty else None for movie_id in recommended_movie_ids]

    recommended_movie_names = [name for name in recommended_movie_names if name is not None]

    recommended_movies_df = pd.DataFrame(recommended_movie_names, columns=['Movie Title'])

    return recommended_movies_df

user_id = 151
recommended_movies_df = recommend_movies(user_id)
print(f"Recommended movies for user {user_id}:")
print(recommended_movies_df)